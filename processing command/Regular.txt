数值运算和运算符：
    声明变量的类型
        declare [+/-][选项] 变量名
            -：给变量设定类型属性
            +：取消变量的类型属性
            -i：整形
            --：字符串类型
            -x:环境变量
            -p:显示指定变量的声明类型
    
        运算1：
            aa=12
            bb=24
            declare -i cc=$aa*$bb
        
        运算2：
            dd=$(expr $aa + $bb) 注意：运算符前后必须加空格
        
        运算3
            ee=$(($aa+$bb))
            
        运算4
            ff=$[$aa+$bb]
    
    运算符的优先级  ():改变运算的优先级，而且()的优先级是最高的。


正则表达式：
    含义：正则表达式就是处理字串的方法，他是以行为单位来进行字串的处理行为，
        正则表达式通过一些特殊符号的辅助，可以让使用者轻易的达到到
        “搜寻/删除/取代”某特定字串的处理程序；

    用途：
        可以让系统管理员管理主机更为便利;
        正则表达式强大的字串处理能力,大部分软件都支持正则表达式；
        正则表达式的字串表示方式依照不同的严谨度而分为：基础正则表达式与延伸正则表达式；

    
    基础正则表达式(LANG=C):        
        对字符排序有影响的语系数据就会对正则表达式的结果有影响；
        正则表达式也需要支持工具程序来辅助，如：grep

        
        语系对正则表达式的影响：
            不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异；
            例:在英文大小写的编码顺序,zh_TW.big5 及 C 这两种语系的输出结果：
                LANG=C 时：0 1 2 3 4 ... A B C D ... Z a b c d ...z 
                LANG=zh_TW 时：0 1 2 3 4 ... a A b B c C d D ... z Z

            使用正则表达式时，需要特别留意当时环境的语系为何，否则可能会发现与别人不相同的撷取结果；

        
        特殊符号：
            [:alnum:] 代表英文大小写字符及数字，即 0-9, A-Z, a-z 
            [:alpha:] 代表任何英文大小写字符，即 A-Z, a-z 
            [:blank:] 代表空白键与 [Tab] 按键两者 
            [:cntrl:] 代表键盘上面的控制按键，即包括 CR, LF, Tab, Del.. 等等 
            [:digit:] 代表数字而已，即 0-9 
            [:graph:] 除了空白字符 （空白键与 [Tab] 按键） 外的其他所有按键 
            [:lower:] 代表小写字符，即 a-z 
            [:print:] 代表任何可以被打印出来的字符 
            [:punct:] 代表标点符号(punctuation symbol),即：" ' ? ! ; : # $... 
            [:upper:] 代表大写字符，即 A-Z 
            [:space:] 任何会产生空白的字符,包括空白键 [Tab] CR 等 
            [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符
            
            #使用正则表达式时，需要特别留意当时环境的语系为何，否则可能会发现与别人不相同的结果；

            搜寻特定字串'the'：
            $grep -n 'the' abc.txt
            $grep -vn 'the' abc.txt(反向选择)

        利用中括号[]来搜寻集合字符：
            $grep -n 't[ae]st' abc.txt  #搜寻 test 或 taste 这两个单字词；
            $grep -n 'oo' abc.txt  #搜寻到有 oo 的字符时；
            $grep -n '[^g]oo' abc.txt #利用在集合字符的反向选择 [^] 来实现；

        行首与行尾字符 ^ $：

        
        正则表达式和通配符的区别：
            正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配， grep、 awk、sed等命令可以支持正则表达式；
            通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、 find、 cp这些命令不支持正则表达式，
                所以只能使用shell自己的通配符来进行匹配了。
        
        
        元字符：
                *       前一个字符串匹配0次或任意多吃
                .       匹配除了换行符外任意一个字符
                ^       匹配行首，例如^hello会匹配以hello开头和行
                $       匹配行尾，例如hello$会匹配以hello结尾的行
                []      匹配中括号中指定的任意字符，只匹配一个字符。[grep]匹配任意一个元音字母
                [^]     匹配除中括号的字符以为的任意一个字符。[^0-9]匹配任意一位非数字字符
                \       转义符，用于取消讲特殊字符号的含义取消
                \{n\}   表示其前面的字符恰好出现n次。[1][3-8][0-9]\{9\}匹配手机号码
                \{n,\}  表示其前面的字符出现不小于n次。[0-9]\{2,\}表示两位及以上的数字
                \{n,m\} 表示其前面的字符至少出现n次，最多出现m次。[a-z]\{6,8\}匹配6到8的小写字母；

        
        字符汇整(characters)：
            ^word：
                意义：待搜寻的字串（word）在行首;
                例：搜寻行首为 # 开始的那一行，并列出行号 grep -n '^#' regular_express.txt ；
                
            word$：
                意义：待搜寻的字串（word）在行尾; 
                例：将行尾为 ! 的那一行打印出来，并列出行号；
                grep -n '!$' regular_express.txt ；
                
            . ：
                意义：代表“一定有一个任意字符”的字符； 
                例：搜寻的字串可以是(eve)(eae)(eee)(e e)，但不能仅有(ee),如 e 与 e 中间“一定”仅
                有一个字符而空白字符也是字符；
                grep -n 'e.e' regular_express.txt ；
                
            \ ：
                意义：跳脱字符，将特殊符号的特殊意义去除； 
                例：搜寻含有单引号 ' 的那一行;
                grep -n \' regular_express.txt 
                
            * : 
                意义：重复零个到无穷多个的前一个 RE 字符 ；
                例：找出含有(es)(ess)(esss)等字串，注意，因为 * 可以是 0 个，所以 es 也是符合带搜寻字串，
                另外，因为 * 为重复“前一个 RE 字符”的符号，因此，在 * 之前必须要紧接着一个 RE 字符，例如任意
                字符则为 “.*” ；
                grep -n 'ess*' regular_express.txt ；
                
            [list] :
                意义：字符集合的 RE 字符，里面列出想要撷取的字符！ 
                例：搜寻含有(gl)或(gd)的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻的字符”， 例如“ a[afl]y ”
                代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思；
                grep -n 'g[ld]' regular_express.txt ；
                
                
            [n1-n2]：
                意义：字符集合的 RE 字符，里面列出想要撷取的字符范围； 
                例：搜寻含有任意数字的那一行！需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的
                所有连续字符,但这个连续与否与ASCII编码有关，因此，你的编码需要设置正确(在 bash 当中，需要确定 LANG 与
                LANGUAGE 的变量是否正确),例如所有大写字符则为 [A-Z] ；
                grep -n '[A-Z]' regular_express.txt ；
                
                
            [^list]：
                意义：字符集合的 RE 字符，里面列出不要的字串或范围； 
                例：搜寻的字串可以是(oog)(ood)但不能是(oot)，那个 ^ 在 [] 内时，代表的意义是“反向选择”的 意思,如我不要大写字符，
                则为 [^A-Z],但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都
                被列出，[^A-Z] 是“非大写字符”的意思， 因为每一行均有非大写字符，例如第一行的 "Open Source" 就有 p,e,n,o.... 等小写字 ；
                grep -n 'oo[^t]' regular_express.txt ；
                
                
            \{n,m\}：
                意义：连续 n 到 m 个的“前一个 RE 字符” ；
                意义：若为 \{n\} 则是连续 n 个的前一个 RE 字符； 
                意义：若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符； 
                例：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串， 如(goog)(gooog)
                grep -n 'go\{2,3\}g' regular_express.txt；

        
            正则表达式的特殊字符与一般在命令行输入指令的“万用字符”并不相同；
                            

            正则案例：
                grep ‘a*’ 文件  (匹配所有的行)
                grep ‘aa*’ 文件 (必须出现一个或多个a相连的字符)
                grep ‘a..d’ 文件 (a和d之间只有两个字符)
                grep ‘a.*d’ 文件 (只要出现了a和d，不管他们中间是否包含字符、或者包含任意个的任意字符都符合要求。)
                
                grep ‘.*’ 文件
                grep ‘^M’ 文件
                grep ‘n$’ 文件
                grep “s[ao]id” 文件
                grep “[0-9]” 文件
                grep “^[a-z]” 文件
                grep “^[^a-z]” 文件
                grep “^[^a-zA-Z]” 文件
                grep ‘\.$’ 文件
                grep “a\{3\}” 文件
                grep “[0-9]\{3\}” 文件
                grep “^[0-9]\{3,\}” 文件
                grep “sa\{3,5\}i” 文件

        
        grep：
            语法：grep [-acinv] [--color=auto] '搜寻字串' filename
            选项与参数： -a：将 binary 文件以 text 文件的方式搜寻数据 
                        -c：计算找到 '搜寻字串' 的次数 
                        -i：忽略大小写的不同，所以大小写都一样 
                        -n：顺便输出行号
                        -v：反向选择，亦即显示出没有 '搜寻字串' 内容的那一行
                        --color=auto：可以将找到的关键字部分加上颜色的显示；
            
                范例1：将 last 当中，有出现 root 的那一行就取出来： 
                        $ last | grep 'root' 
                
                范例2：与范例一相反，只要没有 root 的就取出： 
                        $ last | grep -v 'root' 
                
                范例3：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏 
                        $ last | grep 'root' |cut -d ' ' -f1 
                            # 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！ 
                
                范例4：取出 /etc/man_db.conf 内含 MANPATH 的那几行：     
                        $ grep --color=auto 'MANPATH' /etc/man_db.conf  
                            # 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示；
                            #CentOS 7 当中，默认的 grep 已经主动加上 --color=auto 在 alias 内了


            语法：grep [-A] [-B] [--color=auto] '搜寻字串' filename 
            选项与参数： -A：后面可加数字,为 after 的意思,除了列出该行外,后续的 n 行也列出来； 
                        -B：后面可加数字,为 befer 的意思,除了列出该行外,前面的 n 行也列出来； 
                        --color=auto 可将正确的那个撷取数据列出颜色；

                范例1：用 dmesg 列出核心讯息，再以 grep 找出内含 abc那行 
                        $ dmesg | grep 'abc'
                        # dmesg 可列出核心产生的讯息！包括硬件侦测的流程也会显示出来； 
                        # 使用的显卡是 QXL 这个虚拟卡，通过 grep 来 abc 的相关信息；

                范例2：将捉到的关键字显色，且加上行号来表示： 
                        $ dmesg | grep -n --color=auto 'abc'
                            # 除了 abc 会有特殊颜色来表示之外，最前面还有行号喔！其实颜色显示已经是默认在 alias 当中了；
                
                范例3：在关键字所在行的前两行与后三行也一起捉出来显示 
                        $ dmesg | grep -n -A3 -B2 --color=auto 'abc'
                        #关键字之前与之后的数行也被显示出来,这样可以让你将关键字前后数据捉出来进行分析；

    延伸正则表达式：
        含义:通过群组功能“ | ”来进行一次搜寻,在单引号内的管线意义为'或 or'；
        特殊字符(RE 字符)：
            + ：
                意义：重复“一个或一个以上”的前一个 RE 字符 ；
                例：搜寻(god)(good)(goood)... 等字串,o+ 代表'一个以上的 o '所以，下面的执行成果会将第 1, 9, 13 行列出来；
                    egrep -n 'go+d' regular_express.txt ；
            ? ：
                意义：“零个或一个”的前一个 RE 字符；
                例：搜寻(gd)(god)这两个字串,o? 代表“空的或 1 个 o ”所以，上面的执行成果会将第 13, 14 行列出来； 
                    egrep -n 'go?d' regular_express.txt ；
            
            | ：
                意义：用或(or)的方式找出数个字串；
                例：搜寻 gd 或 good 这两个字串，注意,是'或',所以，第 1,9,14 这三行都可以被打印出来,找出 dog： 
                    egrep -n 'gd|good' regular_express.txt 
                    egrep -n 'gd|good|dog' regular_express.txt 
            
            （） ：
                意义：找出“群组”字串 ；
                例：搜寻(glad)或(good)这两个字串，因为 g 与 d 是重复的，所以，可以将 la 与 oo 列于()当中，并以 | 来分隔开来： 
                    egrep -n 'g（la|oo）d' regular_express.txt 
            
            （）+ :
                意义：多个重复群组的判别；
                例：将“AxyzxyzxyzxyzC”用 echo 叫出，然后再使用如下的方法搜寻一下； 
                    echo 'AxyzxyzxyzxyzC' | egrep 'A（xyz）+C' 
                    (找开头是 A 结尾是 C,中间有一个以上的 "xyz" 字串)

            想查出文件含有！和 >的字行时：
                grep -n '[!>]' regular_express.txt
                (!在正则表达式当中并不是特殊字符)
        
        常见的支持正则表达式的工具软件有： grep , sed, vim 等;

    
文件的格式化与相关处理：将讯息进行排版的动作
    格式化打印：printf
        语法：$ printf '打印格式' 实际内容 
        选项与参数： 
            关于格式方面的几个特殊样式： 
                \a :    警告声音输出；
                \b :    倒退键（backspace）；
                \f :    清除屏幕 （form feed）；
                \n :    输出新的一行；
                \r :    如 Enter 按键；
                \t :    水平的 [tab] 按键；
                \v :    垂直的 [tab] 按键；
                \xNN NN :为两位数的数字，可以转换数字成为字符,关于 C 程序语言内，常见的变量格式； 
                %ns : n 是数字，s 代表 string ，如多少个字符；
                %ni : n 是数字，i 代表 integer ，如多少整数码数； 
                %N.nf : n 与 N 都是数字，f 代表 floating(浮点)，如果有小数码数(假设我共要十个位数，但小数点有两位，为 %10.2f)；
            (printf 可以通过一些特殊符号来将数据进行格式化输出)

    数据处理工具：awk
        语法：$ awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
            awk 后面接两个单引号并加上大括号 {} 来设置想要对数据进行的处理动作；
            awk 可以处理后续接的文件，也可以读取来自前个指令的 standard output；
            awk 主要是处理“每一行的字段内的数据”，而默认的“字段的分隔符号为"空白键"或"[tab]键"；

        awk括号内，每一行的每个字段都是有变量名称的，就 $1, $2... 等变量名称；
        awk 是“以行为一次处理的单位”， 而“以字段为最小的处理单位；
        awk 可以使用“字段”为依据，进行数据的重新整理与输出；

        awk的处理流程：
            读入第一行，并将第一行的数据填入 $0, $1, $2.... 等变量当中； 
            依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"； 
            做完所有的动作与条件类型； 
            若还有后续的“行”的数据，则重复前面的步骤，直到所有的数据都读完为止；

        
        awk内置变量:
           NF 每一行 （$0） 拥有的字段总数； 
           NR 目前 awk 所处理的是“第几行”数据；
           FS 目前的分隔字符，默认是空白键；

        
        awk的逻辑运算字符：
            >       大于 
            <       小于 
            >=      大于或等于 
            <=      小于或等于 
            ==      等于 
            !=      不等于

            注意"=="符号：
                逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以“ == ”来表示； 
                如果是直接给予一个值，例如变量设置时，就直接使用 = 而已；

        awk注意事项说明:
            awk 的指令间隔：所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个指令辅助时，可利用分号“;”间隔， 
            或者直接以 [Enter] 按键来隔开每个指令；
            
            逻辑运算当中，如果是“等于”的情况，则务必使用两个等号“==”； 
            
            格式化输出时，在 printf 的格式设置当中，务必加上 \n ，才能进行分行； 
            
            与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号；


    文件比对工具:同一个套装软件的不同版本之间，比较配置文件与原始文件的差异；
        diff:用在比对两个文件之间的差异的，以行为单位来比对；
            diff 通常是用在同一的文件（或软件）的新旧版本差异；
            语法；$ diff [-bBi] from-file to-file 
            
            选项与参数： 
                from-file ：一个文件名，作为原始比对文件的文件名； 
                to-file ：一个文件名，作为目的比对文件的文件名,注意，from-file 或 to-file可以 - 取代， - 代表“Standard input”; 
                -b ：忽略一行当中，仅有多个空白的差异（例如 "about me" 与 "about me" 视为相同；
                -B ：忽略空白行的差异； 
                -i ：忽略大小写的不同；
                (不要用 diff 去比对两个完全不相干的文件)

        cmp：主要也是在比对两个文件，主要利用“字节”单位去比对,也可以比对 binary file；
            语法：$ cmp [-l] file1 file2 
            选项与参数： 
                -l ：将所有的不同点的字节处都列出来,因为 cmp 默认仅会输出第一个发现的不同点；

        
        patch：可以将旧版数据更新到新版(主要由diff创建patch的补丁来源文件)；
            使用 diff 制作出来的比较文件通常使用扩展名为 .patch ；
            语法:$patch -pN < patch_file        #更新 
                 $patch -R -pN < patch_file     #还原 
            选项与参数： 
                -p ：后面可以接“取消几层目录”的意思;
                -R ：代表还原，将新的文件还原成原来旧的版本；

    sed 工具：
        sed 是一个管线命令，将数据进行取代、删除、新增、撷取特定行等等的功能；
        语法：$ sed [-nefr] [动作] 
        选项与参数： -n ：使用安静(silent)模式,一般的 sed 用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。 但如果加上 -n 参数后，
                    则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来； 
                    
                    -e ：直接在命令行界面上进行 sed 的动作编辑；
                    -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作;；
                    -r ：sed 的动作支持的是延伸型正则表达式的语法(默认是基础正则表达式语法)；
                    -i ：直接修改读取的文件内容，而不是由屏幕输出；
        
        动作说明： [n1[,n2]]function 
            n1, n2 ：不见得会存在，一般代表“选择进行动作的行数”，举例来说，如果我的动作 是需要在 10 到 20 行之间进行的，则“ 10,20[动作行为] ” ；
            
        function 有下面这些： 
            a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）；
            c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行; 
            d ：删除，因为是删除,所以 d 后面通常不接任何；
            i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现（目前的上一行）； 
            p ：打印，如将某个选择的数据印出,通常 p 会与参数 sed -n 一起运行；
            s ：取代，可以直接进行取代的工作,通常这个 s 的动作可以搭配正则表达式,如 1,20s/old/new/g ；

        


字符截取命令:
    cut:
        格式： cut [选项] 文件名
        选项:
                if 列号：提取第几列
                -d 分隔符：按照指定分隔符分割列	
        案例:批量删除普通用户	

    awk：
        格式：  awk ‘条件1{动作1}条件2{动作2}...’ 文件名
                条件一般使用关系表达式作为条件：age > 18
            动作：
                格式化输出 print printf
                流程控制语句
        
        示例
            awk ‘{printf $2 “\t” $6 “\n”}’ 文件
            df -h | awk ‘print $1 “\t” $3’
            案例：提取根目录使用率
        
        特殊用法：
            BEGIN:首先执行：awk ‘BEGIN{print “this is a ...”}{printf $2 “\n”}’
            FS内置变量：指定分隔符：awk ‘BEGIN{FS=”:”}{printf $2 “\n”}
            END：最后执行：awk ‘END{print “the end!”}{print $1}’ 文件名
            案例：批量删除普通用户


    sed：
        作用：轻量级流编辑器主要用来将数据进行选取、替换、删除、新增。
        格式：sed [选项] ‘[动作]’ 文件名
        选项：  -n: 一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。
                -e：允许对输入数据应用多条sed命令编辑
                -i: 用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出
        
        动作：  a\:追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用'\'代表数据未完结。
                c\:行替换，用C后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用'\'代替数据未完结。
                i\:插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用'\'代表数据未完结。
                d:删除，删除指定的行。
                p:打印，输出指定的行。
                s:字串替换，用一个字符替换另外一个字符串。格式为'行范围s/旧字串/新字串/g'(和vim中的替换格式类似)

        案例：
            sed ‘2p’ 文件
            sed -n ‘2p’ 文件
            sed ‘2,4d’ 文件
            sed ‘2a hello’ 文件
            sed ‘2i hello\kangkang’ 文件