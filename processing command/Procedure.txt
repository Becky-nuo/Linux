
程序：
    触发任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 ID,称为 PID，
    同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限设置；
    
    程序与程序：(（process & program)；
        程序(program)：通常为 binary program ，放置在储存媒体中(如硬盘、光盘、软盘、磁带等)为实体文件的型态存在；
        
        程序(process)：程序被触发后，执行者的权限与属性、程序的程序码与所需数据等都会被载入内存中，
        操作系统并给予这个内存内的单元一个识别码(PID)，程序就是一个正在运行中的程序；

    fork and exec：程序调用的流程：
        在 Linux 的程序调用通常称为 fork- and-exec 的流程,程序都会借由父程序以复制(fork)的方式产生一个一模一样的子程序， 
        然后复制出来子程序,最终就成为一个子程序的存在；

    Linux的多用户多任务环境：
        多人环境：在 Linux 系统上面具有多种不同的帐号，每种帐号都有都有其特殊的权限，只有一个人具有至高无上的权力，那就是 root (系统管理员);
        多任务行为;CPU 切换程序的工作，与这些工作进入到 CPU 运行的调度(CPU 调度，非 crontab 调度)会影响到系统的整体性能；
        
        多重登陆环境的七个基本终端窗口：在 Linux 当中，默认提供了六个文字界面登陆窗口和一个图形界面，可以使用 [Alt]+[F1].....[F7] 
        来切换不同的终端机界面，而且每个终端机界面的登陆者还可以不同人；
        
        bash 环境下的工作管理(job control)：在一串指令中，重点在那个 & 的功能，他表示将 file1 这个文件复制为 file2，且放置于背景中执行，
        也就是说执行这一个命令之后，在这一个终端接口仍然可以做其他的工作；

    
    工作管理：
        进行工作管理的行为中，每个工作都是目前 bash 的子程序，之间是有相关性的,无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash；
        在可以出现提示字符让你操作的环境就称为前景(foreground),至于其他工作就可以让你放入背景(background)去暂停或运行；

        进行 bash 的 job control 的限制是：
            这些工作所触发的程序必须来自于你 shell 的子程序(只管理自己的 bash)； 
            前景：你可以控制与下达指令的这个环境称为前景的工作(foreground)； 
            背景：可以自行运行的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 调用该工作；
            背景中“执行”的程序不能等待 terminal/shell 的输入(input)；

        job control 的管理：
            直接将指令丢掉背景中执行的&:在该指令的最后面加上一个“ & ”代表将该指令丢到背景中，bash会给予这个指令一个'工作号码(job number)'
            是该指令所触发的“ PID ”；

        观察目前的背景工作状态: jobs
            语法：$ jobs [-lrs] 
            选项与参数： 
                -l ：除了列出 job number 与指令串之外，同时列出 PID 的号码；
                -r ：仅列出正在背景 run 的工作；
                -s ：仅列出正在背景当中暂停(stop)的工作；

            + 代表最近被放到背景的工作号码，- 代表最近最后第二个被放置到背景中的工作号码；

        将背景工作拿到前景来处理: fg
            语法：$ fg %jobnumber 
            选项与参数： 
                %jobnumber：jobnumber 为工作号码(数字)，# % 是可有可无的；

        管理背景当中的工作：kill
            语法：$ kill -l 
            选项与参数： 
                -l ：这个是 L 的小写，列出目前 kill 能够使用的讯号(signal)；
                signal ：代表给予后面接的那个工作什么样的指示,用 man 7 signal 可知： 
                    -1 ：重新读取一次参数的配置文件(类似 reload)；
                    -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
                    -9 ：立刻强制删除一个工作；
                    -15：以正常的程序方式终止一项工作,与 -9 是不一样的；
                    (-9  signal 通常是用在“强制删除一个不正常的工作”时所使用的， -15 则是以正常步骤结束一项工作(15也是默认值)；

    特殊文件：
        SUID的权限：
            SUID 权限仅对二进制程序(binary program)有效； 
            执行者对于该程序需要具有 x 的可执行权限； 
            本权限仅在执行该程序的过程中有效(run-time)； 
            执行者将具有该程序拥有者(owner)的权限；
        
        /proc/*代表的意义:主机的各个程序的 PID 以目录的型态存放；

        相关文件:
            /proc/cmdline：载入 kernel 时所下达的相关指令与参数,查阅此文件，可了解指令是如何启动的；
            /proc/cpuinfo：本机的 CPU 的相关信息，包含频率、类型与运算功能等；
            /proc/devices：文件记录了系统各个主要设备的主要设备代号，与 mknod 有关；
            /proc/filesystems：目前系统已经载入的文件系统； 
            /proc/interrupts：目前系统上面的 IRQ 分配状态了； 
            /proc/ioports：目前系统上面各个设备所配置的 I/O 位址；
            /proc/kcore：内存的大小,但不要读它； 
            /proc/loadavg：top 以及 uptime ,三个平均数值就是记录在此； 
            /proc/meminfo：使用 free 列出的内存信息，在这里也能够查阅到； 
            /proc/modules：Linux 已经载入的模块列表，也可以想成是驱动程序； 
            /proc/mounts：系统已经挂载的数据，就是用 mount 这个指令调用出来的数据； 
            /proc/swaps：使用掉的 partition 就记录在此； 
            /proc/partitions：使用 fdisk -l 会出现目前所有的 partition，在这个文件当中也有纪录；
            /proc/uptime：用 uptime 的时候，会出现的信息； 
            /proc/version：核心的版本，就是用 uname -a 显示的内容； 
            /proc/bus/*：一些总线的设备，还有 USB 的设备也记录在此；
        
        fuser：
            功能：借由文件(或文件系统)找出正在使用该文件的程序；
            语法：$ fuser [-umv] [-k [i] [-signal]] file/dir 
            选项与参数： 
                -u：除了程序的 PID 之外，同时列出该程序的拥有者； 
                -m：后面接的那个文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效；
                -v：可以列出每个文件与程序还有指令的完整相关性； 
                -k：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID； 
                -i：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿； 
                -signal：如 -1 -15 等，若不加的话，默认是 SIGKILL(-9)；
        
        lsof：
            功能：列出被程序所打开的文件文件名；
            语法：$ lsof [-aUu] [+d] 
            选项与参数：
                -a：多项数据需要“同时成立”才显示出结果时； 
                -U：仅列出 Unix like 系统的 socket 文件类型； 
                -u：后面接 username，列出该使用者相关程序所打开的文件； 
                +d：后面接目录，亦即找出某个目录下面已经被打开的文件；
        
        pidof：
            功能：找出某支正在执行的程序的PID；
            语法：$ pidof [-sx] program_name 
            选项与参数： 
                -s：仅列出一个 PID 而不列出所有的 PID；
                -x：同时列出该 program name 可能的 PPID 那个程序的 PID；
    





